//#pragma config(Sensor, S1,     touchSensor,    sensorTouch)
#pragma config(Sensor, S2,     lightSensor,    sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* navigating and recording. returning directly to the start. calculate the cell location and display on the screen.
		compute direct path to closest one. SPEED. flair. freeform modification.
*/

//const tSensors touchSensor = (tSensors) S1;
const tSensors lightSensor = (tSensors) S2;

//protoypes
void reverse(void);
void moveToCentre(void);
void moveToEdge(void);
void changeDirection(void);
void updateObstacleMap(void);
void navigateGrid(void);
void bounds(void);
void left(void);
void right(void);

// declaring grid & global variables
int grid[9][11];
int currentColumn = 1;
int currentRow = 4;
int tleft = 2; //turn left
int tright = 3; //turn right
int num; //for random turning left or right
/* directions:
	 1 is north
	 3 is south
	 2 is east
	 4 is west
*/
int direction = 3;
int thresholdValue;
//to help with turns so it wont "array out of bounds", left = 4, right = 6;
int lastTurn = 4;


task main()
{
	thresholdValue = 40;
	int i, j;
	

	while(true)
	{
		// 0 is white, 99 is start
		// initialise our grid
		for(i = 0; i < 9; i++)
		{
			for(j = 0; j < 11; j++)
			{
				grid[i][j] = 0;
			}
		}
		grid[1][4] = 99;


		while(1==1)
		{
			navigateGrid();
		}//while(1==1)

	}//while(true)

}//end main()

void navigateGrid(void)
{
		while(SensorValue(lightSensor) > 40)
		{
			motor[motorB] = 50;
			motor[motorC] = 50;
			wait1Msec(200);

			//when black line
			while(SensorValue(lightSensor) < 40)
			{
				//call moveToEdge()
				moveToEdge();

				if (SensorValue(lightSensor) < 40)
				{
					//In a black Cell
					updateObstacleMap();
					//check bounds
					bounds();
					//Need to avoid obstacle	
					changeDirection();
					
					
				}//end if
				else
				{
					// We are in a white Cell
					moveToCentre();
					break;
				}//end else
				
		}//end while(<40)

	}//end while(>40)

}//end navigateGrid()

void updateObstacleMap(void)
{
	if (direction == 1)
		{
			//If facing north, row above, same column is black
			grid[currentColumn][currentRow+1] = 1;
		}
	else if (direction == 2)
		{
			//If facing east, same row, next column is black
			grid[currentColumn+1][currentRow] = 1;
		}
	else if (direction == 3)
		{
			//If facing south, row below, same column is black
			grid[currentColumn][currentRow-1] = 1;
		}
	else
		{
			//If facing west, same row, previous column is black
			grid[currentColumn-1][currentRow] = 1;
		}
}

void changeDirection()
{
	//Reverse back to centre of the cell and change direction
	reverse();
	
	//randomly generate left or right turn
	num = rand() % tright + tleft;

	if (num == 2)
	{
		//turn left
		left();
	}//end if
	else if(num == 3)
	{
		//turn right
		right();
	}//end if
}

void bounds()
{
	if(currentColumn == 1)
	{
		if(direction == 3)
		{
			reverse();
			left();
			updateObstacleMap();
		}//end 1s inner if
		
		if(direction == 4)
		{
			reverse();
			right();
			updateObstacleMap();
		}//end 2nd inner if
	}//end if
	
	if(currentColumn == 10)
	{
		if(direction == 3)
		{
			reverse();
			left();
			updateObstacleMap();
		}//end 1s inner if
		
		if(direction == 4)
		{
			reverse();
			right();
			updateObstacleMap();
		}//end 2nd inner if
	}//end if
	
	if(currentRow == 1)
	{
		if(direction == 3)
		{
			reverse();
			right();
			updateObstacleMap();
		}//end 1s inner if
		
		if(direction == 4)
		{
			reverse();
			left();
			updateObstacleMap();
		}//end 2nd inner if
	}//end if
	
	if(currentRow == 8)
	{
		if(direction == 3)
		{
			reverse();
			left();
			updateObstacleMap();
		}//end 1s inner if
		
		if(direction == 4)
		{
			reverse();
			right();
			updateObstacleMap();
		}//end 2nd inner if
	}//end if
}//end bounds()

	
void moveToCentre()
{
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorB] = 90;
	nMotorEncoderTarget[motorC] = 90;
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait1Msec(250);

	if (direction == 1)
	{
		currentRow = currentRow - 1;
	}
	else if (direction == 2)
	{
		
		currentColumn = currentColumn+1;
	}
	else if (direction == 3)
	{
		currentRow = currentRow + 1;
	}
	else
	{
		currentColumn = currentColumn-1;
	}
	//nxtDisplayClearTextLine(4);
	//nxtDisplayCenteredTextLine(4, "Col: %d, Row: %d",currentColumn, currentRow);
	//wait1Msec(250);
}//end moveToCentre()


void moveToEdge(void)
{
	//move a tiny bit
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorB] = 60;
	nMotorEncoderTarget[motorC] = 60;
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait1Msec(250);
}//end moveToEdge()

void reverse(void)
{
	//reverse a tiny bit
	motor[motorB] = -50;
	motor[motorC] = -50;
	wait1Msec(175);
}

void left(void)
{
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorB] = 185;
	nMotorEncoderTarget[motorC] = -18;
	motor[motorB] = 50;
	motor[motorC] = -50;

	while(nMotorRunState[motorC] != runStateIdle)
	{}

	motor[motorB] = 0;
	motor[motorC] = 0;
	
	// Change facing direction
	direction--;
	if(direction <= 0)
	{
		direction = 4;
	}//end if

	// change lastTurn to be left
	lastTurn = 4;
}//end left()

void right(void)
{
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorB] = 185;
	nMotorEncoderTarget[motorC] = -185;
	motor[motorB] = -50;
	motor[motorC] = 50;

	while(nMotorRunState[motorC] != runStateIdle)
	{}

	motor[motorB] = 0;
	motor[motorC] = 0;
	
	// Change facing direction
	direction++;
	if(direction >= 5)
	{
		direction = 1;
	}//end if

	// change lastTurn to be right
	lastTurn = 6;
}//end right()
