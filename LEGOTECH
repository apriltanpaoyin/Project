#pragma config(Sensor, S1,     touchSensor,    sensorTouch)
#pragma config(Sensor, S2,     lightSensor,    sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* navigating and recording. returning directly to the start. calculate the cell location and display on the screen.
		compute direct path to closest one. SPEED. flair. freeform modification.
*/

const tSensors touchSensor = (tSensors) S1;
const tSensors lightSensor = (tSensors) S2;

//protoypes
void reverse(void);
void moveToCentre(void);
void moveToEdge(void);
void reverseToCentre(void);
void changeDirection(void);
void updateObstacleMap(void);
void navigateGrid(void);
void bounds(void);
void left(void);
void right(void);
void objectStart(void);

// declaring grid & global variables
int grid[7][9];
int currentColumn = 0;
int currentRow = 3;
int tleft = 2; //turn left
int tright = 3; //turn right
int num; //for random turning left or right

/* directions:
	 1 is north
	 3 is south
	 2 is east
	 4 is west
*/
int direction = 3;
int thresholdValue;

//to help with turns so it wont "array out of bounds", left = 4, right = 6;
int lastTurn = 4;
int objectCounter;

task main()
{
	thresholdValue = 40;
	int i, j;

	
	while(true)
	{
		// 0 is white, 99 is start
		// initialise our grid
		for(i = 0; i < 7; i++)
		{
			for(j = 0; j < 9; j++)
			{
				grid[i][j] = 0;
			}
		}
		grid[1][4] = 99;


		while(1==1)
		{
			navigateGrid();
			if (objectCounter > 2) // should not be more then 2 unless back at start
			{
				break; //ends program
			}
			
		}//while(1==1)

	}//while(true)

}//end main()

void navigateGrid(void)
{
		while(SensorValue(lightSensor) > 40) //when white square keep going forward
		{
			motor[motorB] = 50;
			motor[motorC] = 50;
			wait1Msec(200);

			//when black line
			while(SensorValue(lightSensor) < 40)
			{
				//call moveToEdge()
				moveToEdge();

				if (SensorValue(lightSensor) < 40)
				{
					//In a black Cell
					updateObstacleMap();
					if (SensorValue(touchSensor) == 1) //when it hits an object
					{
						reverseToCentre();
						objectCounter++;
						if( objectCounter == 2) //when both objects have been found, it returns to start
						{
							objectStart(); 
						}
					}
					//facing north
					while(direction == 1 && currentRow == 0)
					{
						changeDirection();
						right();
					}//end while
					
					//facing east
					while(direction == 2 && currentColumn == 9)
					{
						changeDirection();
						right();
					}//end while
					
					//facing south
					while(direction == 3 && currentColumn == 9)
					{
						changeDirection();
						right();
					}//end while
					
					//facing west
					while(direction == 4 && currentRow == 0)
					{
						changeDirection();
						right();
					}//end while
					
				}//end if
				else
				{
					// We are in a white Cell
					moveToCentre();
					break;
				}//end else
				
		}//end while(<40)

	}//end while(>40)

}//end navigateGrid()

void updateObstacleMap(void)
{
	if (direction == 1)
		{
			//If facing north, row above, same column is black
			grid[currentColumn][currentRow+1] = 1;
		}
	else if (direction == 2)
		{
			//If facing east, same row, next column is black
			grid[currentColumn+1][currentRow] = 1;
		}
	else if (direction == 3)
		{
			//If facing south, row below, same column is black
			grid[currentColumn][currentRow-1] = 1;
		}
	else
		{
			//If facing west, same row, previous column is black
			grid[currentColumn-1][currentRow] = 1;
		}
}

void changeDirection()
{
	//Reverse back to centre of the cell and change direction
	reverse();
	
	//randomly generate left or right turn
	num = rand() % tright + tleft;

	if (num == 2)
	{
		//turn left
		left();
	}//end if
	else if(num == 3)
	{
		//turn right
		right();
	}//end if
}

void bounds() //detects whether the robot is at the edge of the map by which part of the array its at
{
	if(currentColumn == 1)
	{
		if(direction == 3)
		{
			reverse();
			left();
			updateObstacleMap();
		}//end 1s inner if
		
		if(direction == 4)
		{
			reverse();
			right();
			updateObstacleMap();
		}//end 2nd inner if
	}//end if
	
	if(currentColumn == 10)
	{
		if(direction == 3)
		{
			reverse();
			left();
			updateObstacleMap();
		}//end 1s inner if
		
		if(direction == 4)
		{
			reverse();
			right();
			updateObstacleMap();
		}//end 2nd inner if
	}//end if
	
	if(currentRow == 1)
	{
		if(direction == 3)
		{
			reverse();
			right();
			updateObstacleMap();
		}//end 1s inner if
		
		if(direction == 4)
		{
			reverse();
			left();
			updateObstacleMap();
		}//end 2nd inner if
	}//end if
	
	if(currentRow == 8)
	{
		if(direction == 3)
		{
			reverse();
			left();
			updateObstacleMap();
		}//end 1s inner if
		
		if(direction == 4)
		{
			reverse();
			right();
			updateObstacleMap();
		}//end 2nd inner if
	}//end if
}//end bounds()

	
void moveToCentre() //move to centre of block
{
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorB] = 90;
	nMotorEncoderTarget[motorC] = 90;
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait1Msec(250);

	if (direction == 1)
	{
		currentRow = currentRow - 1;
	}
	else if (direction == 2)
	{
		
		currentColumn = currentColumn+1;
	}
	else if (direction == 3)
	{
		currentRow = currentRow + 1;
	}
	else
	{
		currentColumn = currentColumn-1;
	}	
}//end moveToCentre()


void moveToEdge(void)
{
	//move a tiny bit
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorB] = 60;
	nMotorEncoderTarget[motorC] = 60;
	motor[motorB] = 50;
	motor[motorC] = 50;
	wait1Msec(250);
}//end moveToEdge()

void reverse(void)
{
	//reverse a tiny bit
	motor[motorB] = -50;
	motor[motorC] = -50;
	wait1Msec(175);
}

void left(void) //make left turn
{
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorB] = 185;
	nMotorEncoderTarget[motorC] = -18;
	motor[motorB] = 50;
	motor[motorC] = -50;

	while(nMotorRunState[motorC] != runStateIdle)
	{}

	motor[motorB] = 0;
	motor[motorC] = 0;
	
	// Change facing direction
	direction--;
	if(direction <= 0)
	{
		direction = 4;
	}//end if

	// change lastTurn to be left
	lastTurn = 4;
}//end left()

void right(void) //make a right turn
{
	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorB] = 185;
	nMotorEncoderTarget[motorC] = -185;
	motor[motorB] = -50;
	motor[motorC] = 50;

	while(nMotorRunState[motorC] != runStateIdle)
	{}

	motor[motorB] = 0;
	motor[motorC] = 0;
	
	// Change facing direction
	direction++;
	if(direction >= 5)
	{
		direction = 1;
	}//end if

	// change lastTurn to be right
	lastTurn = 6;
}//end right()

void reverseToCentre(void) //go backwards to cetnre block
{
	nMotorEncoder[motorB] = 0;
	nMotorEncoder[motorC] = 0;
	nMotorEncoderTarget[motorB] = 90;
	nMotorEncoderTarget[motorC] = 90;
	motor[motorB] = -50;
	motor[motorC] = -50;
	wait1Msec(250);

	if (direction == 1)
	{
		currentRow = currentRow - 1;
	}
	else if (direction == 2)
	{
		
		currentColumn = currentColumn+1;
	}
	else if (direction == 3)
	{
		currentRow = currentRow + 1;
	}
	else
	{
		currentColumn = currentColumn-1;
	}	
}//end reverseToCentre()

void objectStart(void)//go back to the start
{
	while( grid != 99)
	{
		while( direction != 4) //to face west
		{
			left();
		}
		moveToCentre();
		if (currentColumn == 0) //moves straight until in first column
		{
			left();
			if (currentRow == 3) //goes left until hits start position
			{
				objectCounter++;
			}
			else
			{
				right();
				if( currentRow == 3) // if didnt find start position ,goes right to find it
				{
					objectCounter++;
				}
		
			}	
		}
	}
} //end objectstart();
