//#pragma config(Sensor, S1,     touchSensor,    sensorTouch)
#pragma config(Sensor, S2,     lightSensor,    sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* navigating and recording. returning directly to the start. calculate the cell location and display on the screen.
		compute direct path to closest one. SPEED. flair. freeform modification.
*/

//const tSensors touchSensor = (tSensors) S1;
const tSensors lightSensor = (tSensors) S2;

//protoypes
void reverseToCentre();
void moveToCentre();
void moveToEdge();
void changeDirection();
void updateObstacleMap(int currentColumn, int currentRow, int direction);
int checkCellColour(int threshold);
void navigateGrid();

// declaring grid
int grid[7][9];
int currentColumn = 0;
int currentRow = 3;

/* directions:
	 1 is north
	 2 is south
	 3 is east
	 4 is west
*/
int direction = 3;

int thresholdValue;
//to help with our random turns, left = 4, right = 6;
int lastTurn = 4;


task main()
{

	int num; //for random turning left or right

	nMotorPIDSpeedCtrl[motorB] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorC] = mtrSpeedReg;
	
	while(true)
	{
		// 0 is white cell, 1 is black cell, 99 is start

		// initialise our grid
		for (int i = 0; i < 4; i++)
		{
			for (int j = 0; i < 4; i ++)
			{
				grid[i][j] = 0;
			}
		}
		grid[0][3] = 99;
	
	
		while(1==1)
		{
			navigateGrid();
		}//while(1==1)
		
}//end main()

void navigateGrid()
{
		int cellColour; //1 for black, 0 for white
		
		//call moveToEdge()
		moveToEdge();
		
		//call 
		cellColour = checkCellColour(thresholdValue);

		if (cellColour == 1)
		{
			// We are in a black Cell
			updateObstacleMap(currentColumn, currentRow, direction);
			// Need to avoid obstacle
			reverseToCentre();
			changeDirection();

		}
		else
		{
			// We are in a white Cell
			moveToCentre();
		}	
}//end navigateGrid()

void moveToEdge()
{
	motor[motorB]=50;
	motor[motorC]=50;
	wait1Msec(250);
	motor[motorB]=0;
	motor[motorC]=0;
}
