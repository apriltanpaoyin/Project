//#pragma config(Sensor, S1,     touchSensor,    sensorTouch)
#pragma config(Sensor, S2,     lightSensor,    sensorLightActive)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/* navigating and recording. returning directly to the start. calculate the cell location and display on the screen.
		compute direct path to closest one. SPEED. flair. freeform modification.
*/

//const tSensors touchSensor = (tSensors) S1;
const tSensors lightSensor = (tSensors) S2;


const int y = 7; //no. of row
const int x = 9; //no. of col

int grid[y][x] = {{0, 0, 1, 0, 0, 0, 0, 0, 1},
									{1, 0, 0, 0, 0, 0, 1, 1, 0},
									{0, 0, 0, 0, 0, 0, 1, 0, 0},
									{5, 0, 0, 1, 1, 0, 0, 0, 0},
									{0, 0, 0, 0, 0, 0, 1, 0, 0},
									{1, 1, 0, 0, 0, 0, 0, 0, 0},
									{1, 0, 0, 0, 0, 0, 0, 0, 1}
									};
//0 = white cell; 1 = black cell; 5 = starting position

//prototypes
void reverse(void);
void left(void);
void right(void);

task main()
{
	int row = 0;
	int col = 0;
	int i = 2; //turn left
	int j = 3; //turn right
	int num; //for random turning left or right


	while(true)
	{
		while(SensorValue(lightSensor) > 40)
		{
			motor[motorB] = 50;
			motor[motorC] = 50;
			wait1Msec(200);

			//when black line
			while(SensorValue(lightSensor) < 40)
			{
				count++; //counting lines here

				if(count2 == 4)
				{
					count2 = 0;
				}//end if


				//increase columns
				if(count2 == 0)
				{
					col++;

        	if(col > 9)
        	{
						motor[motorB] = 0;
						motor[motorC] = 0;
        	}//end if

        	array[row][col] = count;
        }//end 1st if
        if(count2 == 1)
        {
        	//decrease col cause going up(?)
					row--;

					if(row < 0)
        	{
						motor[motorB] = 0;
						motor[motorC] = 0;
        	}//end if

          array[row][col] = count;
       	}//end 2nd if
       	else if(count2 == 2)
       	{
       		col--;

       		if(col < 0)
        	{
						motor[motorB] = 0;
						motor[motorC] = 0;
        	}//end if

          array[row][col] = count;
       	}//end 3rd if
       	else if(count2 == 3)
       	{
       		row++;

       		if(row > 9)
        	{
						motor[motorB] = 0;
						motor[motorC] = 0;
        	}//end if

       		array[row][col] = count;
       	}//end 4th if

				//move a bit to detect black cell or white cell
				nMotorEncoder[motorB] = 0;
				nMotorEncoder[motorC] = 0;
				nMotorEncoderTarget[motorB] = 60;
				nMotorEncoderTarget[motorC] = 60;
				motor[motorB] = 50;
				motor[motorC] = 50;
				wait1Msec(250);

     		if(SensorValue(lightSensor) < 40)
				{
					//decide to turn in a direction randomly
					num = rand() % j + i;

					reverse();
					if(num == 2)
					{
						left();
					}//end if for turn left
					else if(num == 3)
					{
						row--;
						right();
					}//end else if for turn right

				}//end outer if

			}//end while when black line

		}//end outer while

	}//end while true
}//end main()


void reverse(void)
{
	motor[motorB] = -50;
	motor[motorC] = -50;
	wait1Msec(175);
}//end reverse()


void left(void)
{
	motor[motorB] = -50;
	motor[motorC] = 50;
	wait1Msec(324);
}//end left()

void right(void)
{
	motor[motorB] = 50;
	motor[motorC] = -50;
	wait1Msec(324);
}//end right()
